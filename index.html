 <!DOCTYPE html>
<!--[if lt IE 8 ]><html class="no-js ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="no-js ie ie8" lang="en"> <![endow]-->
<!--[if (gte IE 8)|!(IE)]><!--><html class="no-js" lang="en"> <!--<![endif]-->
<head>

   <!--- Basic Page Needs -->
   <meta charset="utf-8">
	<title>Elliott Biondo</title>
	<meta name="description" content="">
	<meta name="author" content="">

   <!-- Mobile Specific Metas -->
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<!-- CSS -->
   <link rel="stylesheet" href="css/default.css">
	<link rel="stylesheet" href="css/layout.css">
   <link rel="stylesheet" href="css/media-queries.css">
   <link rel="stylesheet" href="css/magnific-popup.css">

    <!-- Script-->
	<script src="js/modernizr.js"></script>

    <!-- Favicons-->
	<link rel="shortcut icon" href="images/favicon.png" >

    <!-- Academicons-->
    <link rel="stylesheet" href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css">

    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</head>

<body style="background-color:#2B2B2B;">

   <!-- Header
   ================================================== -->
   <header id="home">

      <nav id="nav-wrap">

         <a class="mobile-btn" href="#nav-wrap" title="Show navigation">Show navigation</a>
	      <a class="mobile-btn" href="#" title="Hide navigation">Hide navigation</a>

         <ul id="nav" class="nav">
            <li class="current"><a class="smoothscroll" href="#home">Home</a></li>
            <li><a class="smoothscroll" href="#about">About</a></li>
            <li><a class="smoothscroll" href="#portfolio">Projects</a></li>
	        <li><a class="smoothscroll" href="#publications">Publications</a></li>
         </ul> <!-- end #nav -->

      </nav> <!-- end #nav-wrap -->

      <div class="row banner">
         <div class="banner-text">
            <h1 class="responsive-headline">Elliott Biondo</h1>
            <h3>
            <span>
            I am a computational nuclear engineer, researcher, and software developer.
            <br>
            I love working on challenging problems to serve the common good.
            </span>
            </h3>
            <hr />
            <ul class="social">
               <li><a href="http://github.com/elliottbiondo", title="GitHub"><i class="fa fa-github"></i></a></li>
               <li><a href="https://www.researchgate.net/scientific-contributions/2092818633_E_Biondo" title="ResearchGate"><i class="ai ai-researchgate-square ai"></i></a></li>
               <li><a href="http://linkedin.com/in/elliottbiondo" title="LinkedIn"><i class="fa fa-linkedin"></i></a></li>
               <li><a href="http://elliottbiondo.com/travel" title="Travel Blog"><i class="fa fa-plane"></i></a></li>
            </ul>
         </div>
      </div>

      <p class="scrolldown">
         <a class="smoothscroll" href="#about"><i class="icon-down-circle"></i></a>
      </p>

   </header> <!-- Header End -->


   <!-- About Section
   ================================================== -->
   <section id="about">
      <div class="row">
         <div class="three columns">
            <img  src="images/profile_pic.jpg" alt="" />

				<div class="minibars">
				   <ul class="skills">
                        <li><span class="minibar-expand cpp"></span><em>C/C++11</em></li>
					    <li><span class="minibar-expand python"></span><em>Python</em></li>
                        <li><span class="minibar-expand cuda"></span><em>CUDA</em></li>
                        <li><span class="minibar-expand matlab"></span><em>MATLAB</em></li>
                        <li><span class="minibar-expand git"></span><em>git</em></li>
                        <li><span class="minibar-expand latex"></span><em>LaTeX</em></li>
					</ul>
				</div> <!-- end skill-bars -->
         </div>


         <div class="nine columns main-col">
            <h2>About Me</h2>
            <p3>
        
I am an Associate Research Staff Member at Oak Ridge National Laboratory
(ORNL) in Oak Ridge, Tennessee. I work in the <a
href="https://www.ornl.gov/division/rnsd/radiation-transport">Radiation
Transport Group</a>, as a developer of the <a
href="https://doi.org/10.1016/j.jcp.2015.12.037">Shift</a> Monte Carlo
radiation transport code. I develop, implement, and analyze new methods for
improving the performance and accuracy of nuclear reactor simulations
on leadership-class supercomputers.

<br>

I grew up in the D.C. metro area, before attending the University of Minnesota
where I double majored in chemical engineering and chemistry.  As an
undergraduate I worked as a process engineering intern at <a
href="http://www.polarfab.com/">Polar Semiconductor Inc.</a> and conducted
research in synthetic organic chemistry in the <a
href="http://noland.chem.umn.edu/">Noland Research Group</a>.  It was during my
junior year that I was first exposed to scientific computing in a numerical
methods course and also became interested in nuclear energy as a way to
mitigate climate change.

<br>

These interests lead me to join the <a
href="http://cnerg.github.io/">Computational Nuclear Engineering Research
Group</a> at the University of Wisconsin, where I earned my Ph.D. in nuclear
engineering. As a graduate student, I had coursework in advanced mathematics,
numerical methods, algorithms, and high-performance computing.  I gained
nuclear engineering analysis experience performing calculations in support of
the <a href="https://shinemed.com/">SHINE Medical
Technologies</a> medical isotope facility.  My software development skills
matured as a leading contributor to the <a
href="https://github.com/pyne/pyne">Python for Nuclear Engineering Toolkit</a>
and as an intern at ORNL working on the <a
href="https://info.ornl.gov/sites/publications/files/Pub46035.pdf">ADVANTG</a>
code.  My <a href="html/files/biondo_dissertation_2016.pdf">dissertation</a> research focused on optimizing Monte Carlo simulations
for biological dose rate calculations for nuclear fusion reactors by
approximating the nuclear transmutation process.

            </p3>
            <div class="row">
               <div class="columns contact-details">
                  <br>
                  <h2>Contact Details</h2>
                     <span>elliott.biondo@gmail.com</span><br>
			      </p>
               </div>



               <div class="columns download">
                  <p>
                  <br>
                     <a href="html/files/biondo_cv.pdf" class="button"><i class="fa fa-download"></i>Download CV</a>
                  </p>
               </div>
            </div> <!-- end row -->
         </div> <!-- end .main-col -->
      </div>
   </section> <!-- About Section End-->


   <!-- Portfolio Section
   ================================================== -->
   <section id="portfolio">

      <div class="row">
         <div class="twelve columns collapsed">
            <h1>Professional works and side projects</h1>
            <!-- portfolio-wrapper -->
            <div id="portfolio-wrapper" class="bgrid-quarters s-bgrid-thirds cf">


               <!-- ----------------------------------------------------------------------------------------------------------------- -->
          	   <div class="columns portfolio-item">
                  <div class="item-wrap">
                     <a href="#modal-svd" title="">
                        <img alt="" src="html/projects/svd/files/svd_square.png">
                          <div class="overlay">
       			              </div>
                           <div class="portfolio-item-meta">
          					      <h6>SVD of Monte Carlo variance reduction parameters</h6>
                              <h7>Analysis</h7>
          					   </div>
                        <div class="link-icon"><i class="icon-plus"></i></div>
                     </a>
                  </div>
          		</div> <!-- item end -->
                <!-- ----------------------------------------------------------------------------------------------------------------- -->

           <!-- ----------------------------------------------------------------------------------------------------------------- -->
       	   <div class="columns portfolio-item">
               <div class="item-wrap">
                  <a href="#modal-gtcadis" title="">
                     <img alt="" src="html/projects/gtcadis/files/gtcadis_square.png">
                      <div class="overlay">
       			      </div>
                        <div class="portfolio-item-meta">
       					      <h6>Optimizing gamma dose rate calculations for nuclear fusion shielding</h6>
                           <h7>Analysis, dissertation</h7>
       					</div>
                     <div class="link-icon"><i class="icon-plus"></i></div>
                  </a>
               </div>
       		</div> <!-- item end -->
            <!-- ----------------------------------------------------------------------------------------------------------------- -->

                <!-- ----------------------------------------------------------------------------------------------------------------- -->
          	   <div class="columns portfolio-item">
                  <div class="item-wrap">
                     <a href="#modal-turbine" title="">
                        <img alt="" src="html/projects/turbine/files/turbine_src_mesh_square.png">
                          <div class="overlay">
       			              </div>
                           <div class="portfolio-item-meta">
          					      <h6>Tetrahedral mesh probability density functions</h6>
                              <h7>C++, Python</h7>
          					   </div>
                        <div class="link-icon"><i class="icon-plus"></i></div>
                     </a>
                  </div>
          		</div> <!-- item end -->
            <!-- ----------------------------------------------------------------------------------------------------------------- -->

           <!-- ----------------------------------------------------------------------------------------------------------------- -->
       	   <div class="columns portfolio-item">
               <div class="item-wrap">
                  <a href="#modal-cuda" title="">
                     <img alt="" src="html/projects/cuda/files/matrix_square.png">
                          <div class="overlay">
       			              </div>
                        <div class="portfolio-item-meta">
       					      <h6>GPU-parallelized matrix LU decomposition with CUDA</h6>
                           <h7>C++, CUDA, coursework</h7>
       			    </div>
                     <div class="link-icon"><i class="icon-plus"></i></div>
                  </a>
               </div>
       		</div> <!-- item end -->
            <!-- ----------------------------------------------------------------------------------------------------------------- -->

           <!-- ----------------------------------------------------------------------------------------------------------------- -->
       	   <div class="columns portfolio-item">
               <div class="item-wrap">
                  <a href="#modal-fam" title="">
                     <img alt="" src="html/projects/family_tree/files/fam.png">
                          <div class="overlay">
       			              </div>
                        <div class="portfolio-item-meta">
       					      <h6>Herald: a Python tool for automatically generating family trees</h6>
                           <h7>Python, side project</h7>
       					   </div>
                     <div class="link-icon"><i class="icon-plus"></i></div>
                  </a>
               </div>
       		</div> <!-- item end -->
            <!-- ----------------------------------------------------------------------------------------------------------------- -->

         <!-- COFFEE CUP EXAMPLE 
          	   <div class="columns portfolio-item">
                  <div class="item-wrap">
                     <a href="#modal-03" title="">
                        <img alt="" src="html/images/portfolio/coffee.jpg">
                        <div class="overlay">
                           <div class="portfolio-item-meta">
          					      <h5>Coffee</h5>
                              <p>Illustrration</p>
          					   </div>
                        </div>
                        <div class="link-icon"><i class="icon-plus"></i></div>
                     </a>
                  </div>
          		</div> 
            </div> 
         </div> 
        -->

        <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-svd" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h3>Singular Value Decomposition (SVD) of Monte Carlo variance reduction parameters</h3>
                  <a href="https://doi.org/10.1016/j.anucene.2020.107327"> 2020 journal article</a>    <br><br>

<!-- --------------------------------------------------------------------- -->
<h4>One-sentence summary</h4>
<!-- --------------------------------------------------------------------- -->
<p>

The Singular Value Decomposition (SVD) matrix factorization technique is shown
to reduce RAM requirements for radiation transport simulation parameters by an
order of magnitude, as demonstrated on the Summit supercomputing with a
realistic nuclear reactor problem.

<!-- --------------------------------------------------------------------- -->
<h4>SVD basics</h4>
<!-- --------------------------------------------------------------------- -->

<p>
Singular Value Decomposition (SVD) is a matrix factorization technique that has
applications in data compression and categorization problems.  For an $m \times
n$ matrix $\mathbf{A}$ the SVD is

$$
\mathbf{A}_{m \times n} 
= \mathbf{U}_{m \times m} \mathbf{\Sigma}_{m \times n} \mathbf{V}_{n \times n}^T,
$$

where $\Sigma$ is a diagonal matrix. In this diagonal matrix, the entries
decrease monotonically. As a result, an estimate of $A$ can be formed by
truncating the $\mathbf{U}$, $\mathbf{\Sigma}$, and $\mathbf{V}$ matrices.
Specifically, an estimate of the $a_{ij}$ entry in the $\mathbf{A}$ matrix can be obtained via:

$$
a_{ij} \approx \sum_{k=1}^K u_{ik} \sigma_{kk} v_{jk},
$$

with $1 < K < n$. In other words, an estimate of the $\mathbf{A}$ matrix &mdash;
referred to as a "reconstruction" &mdash; can be obtained by storing only
the first $K$ rows in $\mathbf{U}$, the first $K$ entries along the diagonal of
$\mathbf{\Sigma}$, and the first $K$ columns in $\mathbf{V}$, which results in
a factor of $\Gamma$ memory savings, where $\Gamma$ is given by

$$
\Gamma = \frac{mn}{mK + K + nK}.
$$

For example, consider the following $1333 \times 1000$ pixel image of a cave
waterfall in Jackson County, AL:

<img  src="html/projects/svd/files/rank_full.png" alt="" height="30%" width="30%" class="center" style="padding:20px;"/>

This image can be represented by a $1333 \times 1000$ matrix, where each entry represents a pixel with a gray-scale value between 0 and 1.
Three reconstructions of this image are shown below.

<img  src="html/projects/svd/files/three_ks.png" alt="" height="80%" width="80%" class="center" style="padding:20px;" />

The $K=100$ reconstruction provides a fairly accurate representation of the
image and requires $\Gamma=5.71$ times less memory.
</p>

<!-- --------------------------------------------------------------------- -->
<h4>Application of SVD to radiation transport</h4>
<!-- --------------------------------------------------------------------- -->
<p>

Monte Carlo (MC) radiation transport calculations are used to assess the safety
and performance of nuclear reactors and other nuclear systems. The MC method uses
a random walk technique to simulate the paths particles (i.e., neutrons or
photons), take as they move through a nuclear system, from birth (via fission
or an external source) to termination (through absorption reactions or by
leaving the spatial boundaries of the system).
Particle paths are recorded as they move through
regions of interest, known as tallies. By simulating a large number of
particles, statistical methods can be used to estimate radiological quantities
such as particle flux, biological dose rate, and reactions rates within these
tallies. 

<p>

One significant downside of MC radiation transport is that when tallies are located
in regions of low particle flux (i.e., regions that few particles pass
through), the convergence rates of tallies may be prohibitively slow. To
address this problem most MC codes employ a class of biased random sampling
techniques known as MC variance reduction (VR).  VR method allow the code to
drastically increase the fraction of compute time spent simulating particles
that are likely to reach the tally, without introducing systematic bias into
the tally results.

<p>

Industry-standard VR methods require a low-order estimate of the adjoint flux
distribution, which describes the "importance" of position/energy phase space
regions to the final result. This information is supplied via "importance
maps": 3D spatial meshes with each mesh cell tagged with
energy-wise adjoint fluxes.  These important maps require a significant amount
of RAM, which can limit the fidelity of the simulation that can be achieved.

<p>

This work explores the novel application of SVD to compress importance maps for
reduced memory requirements. In the example above, the $\mathbf{A}$ matrix
represents the two spatial dimensions of the waterfall image. Here, the 3
spatial dimensions of the importance maps are collapsed such that the 2
dimensions of the $\mathbf{A}$ matrix represent the spatial mesh cells and
discrete energy groups of the adjoint flux. This allows an $A$ matrix to be
formulated as:

$$   \mathbf{A}  =
  \begin{bmatrix}
    \phi^{\dagger \, g = 0}_{c = 0} &  \phi^{\dagger \, g = 1}_{c = 0} & \dots &  \phi^{\dagger \, g = N_g - 1}_{c = 0} \\[0.3cm]
    \phi^{\dagger \, g = 0}_{c = 1} &  \phi^{\dagger \, g = 1}_{c = 1} & \dots &  \phi^{\dagger \, g = N_g - 1}_{c = 1} \\[0.3cm]
    \vdots & \vdots & \ddots & \vdots \\[0.3cm]
    \phi^{\dagger \, g = 0}_{c = N_{c} - 1} &  \phi^{\dagger \, g = 1}_{c = N_{c} - 1} & \dots &  \phi^{\dagger \, g = N_g - 1}_{c = N_{c} - 1} \\[0.3cm]
  \end{bmatrix},
$$

where $\phi^{\dagger}$ denotes the adjoint flux, $g$ denotes the energy group
index, and $c$ denotes the spatial mesh cell index. Since adjoint flux distributions may
vary by 10 orders of magnitude or more, and SVD in log-space was also considered, i.e.,

$$
   \mathbf{A}  =
  \begin{bmatrix}
    \log\left(\phi^{\dagger \, g = 0}_{c = 0}\right) &  \log\left(\phi^{\dagger \, g = 1}_{c = 0}\right) & \dots &  \log\left(\phi^{\dagger \, g = N_g - 1}_{c = 0}\right) \\[0.3cm]
    \log\left(\phi^{\dagger \, g = 0}_{c = 1}\right) & \log\left(\phi^{\dagger \, g = 1}_{c = 1}\right) & \dots &  \log\left(\phi^{\dagger \, g = N_g - 1}_{c = 1}\right) \\[0.3cm]
    \vdots & \vdots & \ddots & \vdots \\[0.3cm]
    \log\left(\phi^{\dagger \, g = 0}_{c = N_{c} - 1}\right) & \log\left(\phi^{\dagger \, g = 1}_{c = N_{c} - 1}\right) & \dots & \log\left(\phi^{\dagger \, g = N_g - 1}_{c = N_{c} - 1}\right) \\[0.3cm]
  \end{bmatrix}.
$$

By storing the truncated SVDs of these $\mathbf{A}$ matricies, rather than the
full matrices themselves, a signicant amount of RAM can be saved. Values of the
adjoint flux can then be reconstructed on-the-fly (i.e., during a simulation).
Both formulations were implemented and performance tested in the <a
href="https://doi.org/10.1016/j.jcp.2015.12.037">Shift</a> Monte Carlo
radiation transport code.

<!-- --------------------------------------------------------------------- -->
<h4>Test problem</h4>
<!-- --------------------------------------------------------------------- -->
<p>

The Westinghouse AP1000 is a Generation III+ nuclear reactor currently being
constructed at several sites in in the US and China. SVD compression of
importance maps was tested for the "excore dosimetry" problem shown below.
This problem consists of a quarter-core model with reflecting boundaries, with
a spherical neutron detector in the excore region (i.e., the region outside the
reactor core), on the $z$-midplane. The image on the left shows a $z$-midplane
slice of this geometry, with the detector shown in green. The image on the
right shows the neutron source distribution from fisison. The objective of the
problem is to transport particles from the fission source, through the
sheilding (shown in burgundy), to the detector, which serves as a tally.

<img src="html/projects/svd/files/ap1000_geom_source.png" alt="" height="75%" width="75%" class="center" style="padding:20px" />

The Denovo 3D discrete ordinates (S$_N$) code was used to obtain an adjoint flux
distribution (importance map) on a 44 $\times$ 44 $\times$ 49 spatial mesh with 28
energy groups. The contour plot below shows the adjoint flux for the
1.4227–1.8268 MeV energy group (i.e., fission neutrons). This plot shows that
fission neutrons experience more than 6 orders of magnitude of attenuation
between the source and detector, which indicates that VR will be necessary.

<img  src="html/projects/svd/files/ap1000_adj_flux.png" alt="" height="50%" width="50%" class="center" style="padding:20px;" />

Because 28 energy groups were used, the $\mathbf{A}$ matrix has an $n$ of 28.
Shift was run using $K = [1, 28]$ with the SVD performed in both linear and log
space. Ten independent trials were run for each $K$. Each trial was run on the
<a href="https://www.olcf.ornl.gov/summit/">Summit supercomputer</a> on 264
nodes with 7 processes per node (due to memory constraints).  The plot below
shows the speedups and corresponding standard deviations for these trials, where
the speedup is defined as the ratio of the convergence rate with VR, to the
convergence rate without VR.

<img  src="html/projects/svd/files/ap1000_speedup.png" alt="" height="45%" width="50%" class="center" style="padding:20px;" />

This plot shows that the two best options are 1) use a rank $K=1$ approximation
with linear SVD, which provides a $\Gamma \approx 28*$ while incurring a
$\sim3\times$ performance penalty, or 2) use a $K=2$ approximation with a log
SVD, which provides a $\Gamma \approx 14$ with no performance penalty.
The results show that taking the SVD of the adjoint flux is an effective
method for reducing the memory requirements of importance maps without a
significant sacrifice in performance. 

<br>
<br>
<i>
* Note for the nuclear engineering audience: this work using the CADIS method and these $\,\Gamma$ values refer only to weight windows. For the $K=1$ SVD in linear space, the biased source can also be compressed by a factor of 28, but for the $K=2$ SVD in log space, the biased source cannot be compressed. These detailed were omitted for brevity. A full explanation is found in the <a href="https://doi.org/10.1016/j.anucene.2020.107327">journal article</a> .
</i>

                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-svd End -->
          <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-gtcadis" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h3>Optimizing gamma dose rate calculations for nuclear fusion shielding</h3>
			      <p>
                    <a href="html/projects/gtcadis/files/biondo_dissertation_2016.pdf">Dissertation</a> <br>
                    <a href="https://doi.org/10.1080/00295639.2016.1275848"> 2017 journal article</a>    <br><br>

</p><h4>One-sentence summary</h4><p>

Stocastic radiation transport simulations are optimized for an important
nuclear fusion analysis scenario in which neutrons generate radioisotopes in
structural materials, resulting in a prolonged source of potentially harmful
gamma radiation.

</p><h4>Theory</h4><p>

One of the challenges of designing and operating nuclear fusion reactors (such
as <a href="https://www.iter.org/mach">ITER</a>) is the creation of radioactive
materials. For most viable nuclear fusion fuels, the process of fusing atomic
nuclei releases high-energy neutrons.  These neutrons can penetrate through the
structural materials of the reactor and convert normally harmless materials
such as the iron in stainless steel or the hydrogen in water into radioactive
isotopes.  Even after the reactor is switched off, these isotopes will persist
and emit high-energy photons (gamma rays) as they decay.
Some of these photons travel to areas where people may be taking measurements
or doing maintenance, so it is necessary to estimate the potential biological
dose rate. This is generally done using Monte Carlo radiation transport, which
involves simulating the paths that particles take as they move through the
reactor and interact with the materials. 

<br><br>

From the standpoint of computer processing power, these calculations are not
possible without employing a class of techniques known as Monte Carlo variance
reduction.  Variance reduction techniques are used to optimize Monte Carlo
transport by first finding an approximate solution to an adjoint formulation of
the problem (though not all techniques are explicitly formulated this way).
This is done with respect to a detector response function. In terms of a
standard optimization problem, the variance of the detector response function
can be thought of as an objective function that should be minimized.  For decay
photons, defining this detector response function is straightforward, as I
demonstrated in earlier work <a
href="https://doi.org/10.1016/j.fusengdes.2016.03.004">[2016 journal
article]</a>.  For the neutrons that produce the decay photons, this process is
much more complicated.

<br><br>

As a component of my dissertation work I developed and implemented a technique
for automatically generating the neutron detector response function in order to
optimize Monte Carlo radiation transport for the aforementioned neutron problem.
The most difficult part of forming this function was approximating the process of "neutron activation"
in which material exposed to neutrons creates a vast network of radioactive 
products. For example when $^{62}\mathrm{Ni}$ is exposed to neutrons, the following reactions, and many more, occur:

$$
{^{62}\mathrm{Ni}}
\xrightarrow{\textrm{(n, $\alpha$)}}
{^{59}\mathrm{Fe}}
\xrightarrow{\beta^-}
{^{59}\mathrm{Co}}
\begin{array}{ll}
\xrightarrow{\textrm{(n, $\gamma$)}}
{^{60}\mathrm{Co}} \\
\xrightarrow{\textrm{(n, $\gamma$)}}
{^{60\mathrm{m}}\mathrm{Co}}
\xrightarrow{\mathrm{IT}}
{^{60}\mathrm{Co}}
\end{array}
$$

In general, composition of materials before and after nuclear irradiation can be
related via the matrix exponential equation:

$$ \vec{N}(t) = e^{\mathbf{A}t} \vec{N}_0,$$

where $\vec{N}_0$ and $\vec{N}(t)$ are vectors describing the composition of a
material before and after neutron irradiation for time $t$. The $\mathbf{A}$ is
a matrix of reaction rates that depend on the rate in which neutrons pass
through a given area (the neutron flux). I developed a set of approximations
that can be used to simplify this matrix exponential such that it becomes a
linear operator with respect to neutron flux.  The details of this process can
be found in my dissertation/journal article linked at the top of this page, but
just for fun I will show the final answer for the optimal neutron detector
response function ($q^+_n$) that results from the approximation of
$\mathbf{A}$:

$$
\begin{align}
q^+_n(E_n, E_p) = \int_{E_p} \text{d}{E_p} \phi^+_p(E_p)
\sum\limits_{c} \lambda_{c, i_c} b_{c, i_c}(E_p)  N_{c,1}(0)  \Bigg\lbrack \Big\lbrack &\sigma_{c, 1 \rightarrow 2}(E_n) \frac{t_{\text{irr}}^{i_c-1}}{(i_c-1)!} \prod\limits_{j=3}^{i_c}  P_{c, j} \Big\rbrack e^{-d_{c, i_c} t_{\text{decay}}}\\
& + \sum_{j=2}^{i_c-1}  \Big\lbrack \sigma_{c, 1 \rightarrow 2}(E_n) \frac{t_{\text{irr}}^{j-1}}{(j-1)!} \prod\limits_{k=3}^{j}  P_{c, k}  \Big\rbrack B_{c,i_c,j}(t_{\text{decay}}) \Bigg\rbrack.
\end{align}
$$

<br>

</p><h4>Demonstration</h4><p>

Here I'll show that my method, which is called Groupwise Transmutation
Consistent Adjoint Driven Importance Sampling (GT-CADIS) improves the
convergence rate of Monte Carlo neutron transport by a factor of $O(10^2)$
relative to the industry-standard method known as Forward-Weighted (FW)-CADIS.
Consider a simple problem shown below consisting of a block of stainless steel
(gray) with a U-shaped air-duct, a neutron source (blue) and a region (orange)
where we'd like to estimate the biological dose rate from photons after neutron
irradiation.

<img  src="html/projects/gtcadis/files/photon_geom.png" alt="" height="60%" width="60%" class="center" style="padding:20px;"/>

Using FW-CADIS, neutron detector response function is shown below.

<img  src="html/projects/gtcadis/files/fwcadis_adj_n_src.png" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

Recall that the variance of this function can be thought of as the guess for
the objective function. With GT-CADIS, the neutron detector response function
has a much different shape: the intensity is much higher in the regions of
stainless steel that border the air duct. Note that only the shape is important here, not the magnitude (or even units!).

<img  src="html/projects/gtcadis/files/gtcadis_adj_n_src.png" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

I generated variance reduction parameters using both detector response
functions and tracked the rate of convergence of Monte Carlo simulations using
each set.  The image below shows the relative error in the neutron flux as a
function of neutron transport processor time using GT-CADIS and FW-CADIS
variance reduction parameters, as well as no variance reduction. Without
variance reduction, the neutron flux converges fastest near the source. With
FW-CADIS the neutron flux converges at a roughly uniform rate throughout the
problem. With GT-CADIS, the neutron flux converges fastest in the area
immediately surrounding the area of interest, as expected.

<img  src="html/projects/gtcadis/files/rel_error_plots.jpg" alt="" height="60%" width="60%" class="center" style="padding:20px;"/>

In order to quantify how much faster the simulation converges with GT-CADIS, the Monte Carlo figure of merit was used, as defined by 

$$ {\text{figure of merit}} = \frac{1}{R^2t_{\text{proc}}}, $$

where R is the relative error of the photon flux in the region of interest
(e.g. the orange sphere in the geometry image) and $t_{\text{proc}}$ is the
neutron transport processor time. The figure of merit converges to a constant
value during a simulation, as seen in the plot below.

<img  src="html/projects/gtcadis/files/fom_big.png" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

The ratio of figure of merits is the speedup. GT-CADIS was found to provide
speedups of $200 \pm 100$ relative to FW-CADIS and $9 \pm 5 \times 10^5$
relative to simulations without variance reduction. In other words, GT-CADIS
drastically reduces the required computational resources necessary for
calculating these photon dose rates.

                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-gtcadis End -->
          <!-- ----------------------------------------------------------------------------------------------------------------- -->

         <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-turbine" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h4>Tetrahedral mesh probability density functions</h4>
			      <p>
                    <a href="https://github.com/pyne/pyne/blob/develop/src/source_sampling.cpp">C++ source</a> 
                    <br>
                    <a href="https://github.com/pyne/pyne/blob/develop/tests/test_source_sampling.py">Unit tests (via Python wrapper)</a>
                    <br>
                    <a href="http://pyne.io/theorymanual/source_sampling.html">Theory, sample calculations to match unit tests</a>
                    <br>
                    <a href="http://pyne.io/usersguide/source_sampling.html">User's guide</a>
                    <br><br>

Nuclear systems analysis often involves using the Monte Carlo approach to
simulate the paths that particles (i.e. neutrons and high-energy photons) take
after they are emitted from a source. This source may be a reactor core,
particle accelerator, or a radioactive seed used in radiation oncology. When
using the Monte Carlo approach, the source must be represented as a probability
density function (PDF) that typically varies as a function of position and
energy (i.e. energy of the emitted particle).  With-industry standard Monte
Carlo radiation transport codes such as <a
href="https://mcnp.lanl.gov/mcnp5.shtml">MCNP5</a>, users must specify these
PDFs through the combination of rudimentary 1-dimensional PDFs such has
histogram, linear, and point-wise distributions.  There are many cases when the
PDF is too complex for this method to be practical, such as cases where
particles are emitted from nuclear fusion plasmas or irradiated structural
materials.

<br><br>

I have added code to the <a href="https://github.com/pyne/pyne">Python for
Nuclear Engineering</a> toolkit for the creation of energy-dependent Cartesian-
or tetrahedral mesh-based PDFs. These PDF can be sampling using unbiased and
biased sampling techniques that allow for the use of Monte Carlo variance
reduction. Sampling is done using the <a
href="http://ieeexplore.ieee.org/document/4245054/?reload=true">Alias
method</a>, which allows for O(1) scaling with respect to the number of
discrete bins in the PDF. My code is written in C++ and also has Python and
Fortran interfaces and can be compiled directly into existing Monte Carlo codes.
More information can be found in the links at the top of this page.

<br><br>

Here's a quick demonstration of how this code can be used to create extremely
complex particle sources.  Consider this CAD model of a turbine rotor I found on
<a href="https://grabcad.com/">GrabCAD</a>. 

<img  src="html/projects/turbine/files/turbine_cad.png" alt="" height="30%" width="30%" class="center" style="padding:20px;"/>

I created a conformal tetrahedral mesh of this model using <a
href="https://cubit.sandia.gov/">CUBIT</a>. I then iterated through tetrahedral
elements of the mesh and assigned a source strength to each element based on the
$x$, $y$, $z$ coordinates of the center of the element using this equation:


$$q(x, y, z) = sin\left(\frac{x^2 + y^2 + (z + 10)^2}{1200}\right) + 1.$$

This equation does not have any physical significance, but it serves as a good
example because it would not be possible to represent using industry-standard
Monte Carlo codes. The resulting particle source PDF is shown below.

<img  src="html/projects/turbine/files/turbine_src_mesh.png" alt="" height="38%" width="38%" class="center" style="padding:20px;"/>

I compiled my C++ routine directly into MCNP via the Fortran interface I
created. I was then able to use the PDF shown above as a particle source for a
photon transport simulation. Below is an image showing the photon flux
distribution.

<img  src="html/projects/turbine/files/turbine_flux.png" alt="" height="45%" width="45%" class="center" style="padding:20px;"/>

Although this example was just for fun, I have used this code as a component of
a software system I created for estimating biological dose rates for nuclear
fusion reactors problems <a href="https://doi.org/10.1016/j.fusengdes.2016.03.004">[2016
journal article]</a>. 


                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-turbine End -->
          <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-cuda" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h4>GPU-parallelized matrix LU decomposition with CUDA</h4>
			      <p>
                    <a href="https://github.com/elliottbiondo/ME759_final_project">C++ source</a> 
                    <br>
                    <a href="html/projects/cuda/files/report.pdf">Report</a> 
                    <br><br>

In grad school, one of my favorite courses was <a
href="http://sbel.wisc.edu/Courses/ME964/">ME759: High-Performance Computing
for Applications in Engineering</a>. The primary focus of this course was GPU
computing with CUDA, though we spent some time with MPI and OpenMP as well.
For my final project, I wrote a program to solve a system of linear equations
on the GPU. The problem I solved takes the form 

$$ A_{n \times n} x_{n \times m} = b_{n \times m} $$

where $A$ is a diagonally-dominant banded matrix with some bandwidth $k$.
Problems of this form may arise when using numerical methods to solve ordinary
and partial differential equations. This equation can be solved in 3 steps: LU
decomposition, forward substitution, and backward substitution.  For brevity,
I'll only discuss the first step here. More details can be found in the links at
the top of this page.  LU decomposition decomposes the $A$ matrix into lower-
and upper-triangular matrices $L$ and $U$:

$$ A = LU. $$

The algorithm I chose for performing this decomposition is shown below.

</p>
<div>
<pre><code>
<number>1</number>    <em>for</em> i = 0 to n−2
<number>2</number>    
<number>3</number>        <em>for</em> j = i+1 to n−1
<number>4</number>            A[j, i] = A[j, i]/A[i,i]
<number>5</number>        <em>end for</em>
<number>6</number>    
<number>7</number>        <em>for</em> j = i+1 to n−1
<number>8</number>            <em>for</em> k = i+1 to n−1
<number>9</number>                A[j, k] = A[j , k] − A[j, i]∗A[i, k]
<number>10</number>           <em>end for</em>
<number>11</number>       <em>end for</em>
<number>12</number>   
<number>13</number>   <em>end for</em>
</code></pre>
</div>
<p>

This algorithm operates on the matrix in-place, such that resultant $L$ and $U$
matrices are produced within the lower and upper triangular portion of the
original $A$ matrix, which helps to minimize memory usage.

<br><br>

I adapted this algorithm to run efficiently on the GPU using CUDA.  This
algorithm requires synchronization after the for-loop on line 3 and the set of
for-loops beginning on line 7. Though CUDA can impose synchronization between
threads within a block, there is no notion of block synchronization. As a
result, the outermost for-loop must occur on the CPU, and this for-loop must
call 2 separate CUDA kernels: one for the line 3 for-loop and one for the line
7 for-loops. The line 7 for-loops offered the best potential for
parallelization.  No synchronization is required over $j$ or $k$, so large
portions of the $A$ matrix can be operated on by different threads
simultaneously. This is illustrated in the following diagram. The rectangles
represent the active region of the matrix for a given kernel call where the
order of kernel calls goes from light to dark.  Within each rectangle,
execution is divided into blocks, and threads within these blocks perform the
operation appearing on line 9 simultaneously.

<img  src="html/projects/cuda/files/matrix.png" alt="" height="30%" width="30%" class="center" style="padding:20px;"/>

Further memory usage reductions were achieved by using the <a
href="http://www.netlib.org/lapack/lug/node124.html">band storage</a>
technique. This technique only stores the values within the band of the matrix. As a result, the active region of the matrix in my implementation proceeds according to the following diagram.

<img  src="html/projects/cuda/files/band_matrix.png" alt="" height="23%" width="23%" class="center" style="padding:20px;"/>

The aforementioned forward and backward substitution steps were also
implemented. The performance of the program was compared to the <a
href="https://software.intel.com/en-us/mkl">Intel Math Kernel Library (MKL)</a>
on the CPU.  The following plot shows the execution time necessarily to solve a
linear system with an $A$ matrix of size $n$, with bandwidths $k$ that are 10%,
50% and 90% of $n$. The results of this plot are for the case where $m=1$, but
scaling analysis was done over $m$ as well.

<img  src="html/projects/cuda/files/cuda_results.png" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

This plot shows that my CUDA implementation is marginally faster than MKL over a range of matrix dimensions and bandwidths.

                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-cuda End -->
         <!-- ----------------------------------------------------------------------------------------------------------------- -->
<!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-fam" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h4>Herald: a Python tool for automatically generating family trees</h4>
			      <p>
                    <a href="https://github.com/elliottbiondo/herald">Python source</a> 
                    <br><br>

I have been researching my genealogy as a hobby for the past 5 years or so.
I've accrued information on hundreds of direct ancestors going back as far as
William the Conqueror (c. 1028 - 1087). There are tons of genealogy tools out
there, but none of them were entirely satisfactory to me. In the throes of
writing my dissertation I needed a fun coding project, so I threw this together
in a few Sunday mornings. This project, which I call Herald, is written in
Python. Herald reads text-based input files and creates
PDF output files via SVG.  This is an ongoing project, so right now only direct
decent is supported (i.e.  parent, grand-parent, ...,
[$N\times$great]-grand-parent).

I came up with a very simple recursive algorithm for generating the tree (which
is a balanced binary tree in the graph-theory sense). 

</p>
<pre><code>
<number>1</number>     <em>function</em> <var>assign_index</var>(Person person, string index)
<number>2</number>         person.set_index(index)
<number>3</number>     
<number>4</number>             <em>if</em> person.mother():
<number>5</number>                 <var>assign_index</var>(person.mother(), person.index() +'1')
<number>6</number>             <em>end if</em>
<number>7</number>     
<number>8</number>             <em>if</em> person.father():
<number>9</number>                 <var>assign_index</var>(person.father, person.index() + '0')
<number>10</number>            <em>end if</em>
<number>11</number>    
<number>12</number>    <em>end function</em>
</code></pre>
<p>

This function is called from the root of the tree (e.g. the person whose
ancestors you'd like to plot). Each person in the tree is assigned an index
string. The length of the string is the generation they belongs to. For
example, <code>'010'</code> denotes the father's mother's father
(great-grandfather) of the root person. The generation that this person belong
to is <code><em>len</em>('101') = 3</code>. In typical family trees, the
left-most branch is the paternal line (i.e. '0000...0') and the right-most
branch is the maternal line (i.e. '1111...1'). When printing a family tree,
members of a given generation can be sorted from left to right by simply
converting index values to binary (e.g. <code>'1101' = 13</code>) and sorting
using the decimal representation. A portion of my family tree is shown below.  

<img  src="html/projects/family_tree/files/fam.png" alt="" height="70%" width="70%" class="center" style="padding:20px;"/>

                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-fam End -->
      </div> <!-- row End --> 
   </section> <!-- Portfolio Section End-->

   <section id="publications">
      <div class="row ">
        <div class="twelve columns">
            <h1>Selected Publications</h1>
            <ol>
            <li> <span>E. Biondo</span>, T. Evans, G. Davidson, S. Hamilton,
            “Singular Value Decomposition of Adjoint Flux Distributions for
Monte Carlo Variance Reduction,” <em>Annals of Nuclear Energy</em>, Vol. 141, 2020. <a href="https://doi.org/10.1016/j.anucene.2020.107327">[link]</a>
            <li> <span>E. Biondo</span>, G. Davidson, T. Pandya, S. Hamilton, T. Evans,
            “Deterministically Estimated Fission Source Distributions for Monte Carlo
            k-Eigenvalue Problems,” <em>Annals of Nuclear Energy</em>, Vol. 119, pp. 7-22, 2018. <a href="https://doi.org/10.1016/j.anucene.2018.04.039">[link]</a>
            <li> <span>E. Biondo</span>, P. Wilson, “Transmutation Approximations for the
            Application of Hybrid Monte Carlo/Deterministic Neutron Transport to Shutdown
            Dose Rate Analysis,” <em>Nuclear Science and Engineering</em>, Vol.  187, Issue
            1, pp. 27-48, 2017. <a href="https://doi.org/10.1080/00295639.2016.1275848">[link]</a>
            <li> <span>E. Biondo</span>, A. Davis, P. Wilson, “Shutdown Dose Rate Analysis with
            CAD Geometry, Cartesian/Tetrahedral Mesh, and Advanced Variance Reduction,”
            <em>Fusion Engineering and Design</em>, Vol. 106, pp. 77–84, 2016. <a href="https://doi.org/10.1016/j.fusengdes.2016.03.004">[link]</a>
            <li> <span>E. Biondo</span>, P. Wilson, “Application of the Multi-Step CADIS Method
            to Fusion Energy Systems Analysis,” <em>International Conference on Mathematics
            & Computational Methods Applied to Nuclear Science & Engineering</em>, Jeju,
            South Korea, 2017.
            </ol>
        </div>
   </div>
   </section> <!-- Publication Section End-->

   <!-- footer
   ================================================== -->
   <footer>
      <div class="row">
         <div id="go-top"><a class="smoothscroll" title="Back to Top" href="#home"><i class="icon-up-open"></i></a></div>
      </div>
   </footer> <!-- Footer End-->

   <!-- Java Script
   ================================================== -->
   <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
   <script>window.jQuery || document.write('<script src="js/jquery-1.10.2.min.js"><\/script>')</script>
   <script type="text/javascript" src="js/jquery-migrate-1.2.1.min.js"></script>

   <script src="js/jquery.flexslider.js"></script>
   <script src="js/waypoints.js"></script>
   <script src="js/jquery.fittext.js"></script>
   <script src="js/magnific-popup.js"></script>
   <script src="js/init.js"></script>

</body>

</html>
