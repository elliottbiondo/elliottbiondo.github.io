 <!DOCTYPE html>
<!--[if lt IE 8 ]><html class="no-js ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="no-js ie ie8" lang="en"> <![endow]-->
<!--[if (gte IE 8)|!(IE)]><!--><html class="no-js" lang="en"> <!--<![endif]-->
<head>

   <!--- Basic Page Needs -->
   <meta charset="utf-8">
	<title>Elliott Biondo</title>
	<meta name="description" content="">
	<meta name="author" content="">

   <!-- Mobile Specific Metas -->
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<!-- CSS -->
   <link rel="stylesheet" href="css/default.css">
	<link rel="stylesheet" href="css/layout.css">
   <link rel="stylesheet" href="css/media-queries.css">
   <link rel="stylesheet" href="css/magnific-popup.css">

    <!-- Script-->
	<script src="js/modernizr.js"></script>

    <!-- Favicons-->
	<link rel="shortcut icon" href="images/favicon.png" >

    <!-- Academicons-->
    <link rel="stylesheet" href="https://cdn.rawgit.com/jpswalsh/academicons/master/css/academicons.min.css">

    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

</head>

<body style="background-color:#2B2B2B;">

   <!-- Header
   ================================================== -->
   <header id="home">

      <nav id="nav-wrap">

         <a class="mobile-btn" href="#nav-wrap" title="Show navigation">Show navigation</a>
	      <a class="mobile-btn" href="#" title="Hide navigation">Hide navigation</a>

         <ul id="nav" class="nav">
            <li class="current"><a class="smoothscroll" href="#home">Home</a></li>
            <li><a class="smoothscroll" href="#about">About</a></li>
            <li><a class="smoothscroll" href="#portfolio">Projects</a></li>
	        <li><a class="smoothscroll" href="#publications">Publications</a></li>
         </ul> <!-- end #nav -->

      </nav> <!-- end #nav-wrap -->

      <div class="row banner">
         <div class="banner-text">
            <h1 class="responsive-headline">Elliott Biondo</h1>
            <h3>
            <span>
            I am a computational nuclear engineer, researcher, and software developer.
            <br>
            I love working on challenging problems to serve the common good.
            </span>
            </h3>
            <hr />
            <ul class="social">
               <li><a href="http://github.com/elliottbiondo"><i class="fa fa-github"></i></a></li>
               <li><a href="https://www.researchgate.net/scientific-contributions/2092818633_E_Biondo"><i class="ai ai-researchgate-square ai"></i></a></li>
               <li><a href="http://instagram.com/elliottbiondo"><i class="fa fa-instagram"></i></a></li>
            </ul>
         </div>
      </div>

      <p class="scrolldown">
         <a class="smoothscroll" href="#about"><i class="icon-down-circle"></i></a>
      </p>

   </header> <!-- Header End -->


   <!-- About Section
   ================================================== -->
   <section id="about">
      <div class="row">
         <div class="three columns">
            <!--<img class="profile-pic"  src="https://drive.google.com/uc?id=1nSTsMiR5cf_xt0xqanmjgpO6ttvgaFRQ" alt="" /> -->
            <img  src="https://drive.google.com/uc?id=1nSTsMiR5cf_xt0xqanmjgpO6ttvgaFRQ" alt="" />

				<div class="minibars">
				   <ul class="skills">
					    <li><span class="minibar-expand python"></span><em>Python</em></li>
                        <li><span class="minibar-expand cpp"></span><em>C++</em></li>
                        <li><span class="minibar-expand cuda"></span><em>CUDA</em></li>
                        <li><span class="minibar-expand matlab"></span><em>MATLAB</em></li>
                        <li><span class="minibar-expand git"></span><em>git</em></li>
                        <li><span class="minibar-expand latex"></span><em>LaTeX</em></li>
					</ul>
				</div> <!-- end skill-bars -->
         </div>


         <div class="nine columns main-col">
            <h2>About Me</h2>
            <p3>
        
I am a postdoctoral researcher at Oak Ridge National Laboratory
(ORNL) in Oak Ridge, Tennessee. I work in the <a
href="https://www.ornl.gov/division/rnsd/radiation-transport">Radiation
Transport Group</a>, as a developer of the <a
href="https://doi.org/10.1016/j.jcp.2015.12.037">Shift</a> Monte Carlo
radiation transport code. I develop, implement, and analyze new methods for
improving the performance and accuracy of nuclear reactor simulations
on leadership-class supercomputers.

<br>

I grew up in the D.C. metro area, before attending the University of Minnesota
where I double majored in chemical engineering and chemistry.  As an
undergraduate I worked as a process engineering intern at <a
href="http://www.polarfab.com/">Polar Semiconductor Inc.</a> and conducted
research in synthetic organic chemistry in the <a
href="http://noland.chem.umn.edu/">Noland Research Group</a>.  It was during my
junior year that I was first exposed to scientific computing in a numerical
methods course and also became interested in nuclear energy as a way to
mitigate climate change.

<br>

These interests lead me to join the <a
href="http://cnerg.github.io/">Computational Nuclear Engineering Research
Group</a> at the University of Wisconsin, where I earned my Ph.D. in nuclear
engineering. As a graduate student, I had coursework in advanced mathematics,
numerical methods, algorithms, and high-performance computing.  I gained
nuclear engineering analysis experience performing calculations in support of
the <a href="https://shinemed.com/">SHINE Medical
Technologies</a> medical isotope facility.  My software development skills
matured as a leading contributor to the <a
href="https://github.com/pyne/pyne">Python for Nuclear Engineering Toolkit</a>
and as an intern at ORNL working on the <a
href="https://info.ornl.gov/sites/publications/files/Pub46035.pdf">ADVANTG</a>
code.  My <a href="https://drive.google.com/uc?id=1P1zolvdd0gvulS6iJ3rjXvLGiOjNbl1M">dissertation</a> research focused on optimizing Monte Carlo simulations
for biological dose rate calculations for nuclear fusion reactors by
approximating the nuclear transmutation process.

            </p3>
            <div class="row">
               <div class="columns contact-details">
                  <br>
                  <h2>Contact Details</h2>
                     <span>elliott.biondo@gmail.com</span><br>
			      </p>
               </div>



               <div class="columns download">
                  <p>
                  <br>
                     <a href="https://drive.google.com/uc?id=1CZEhcZ93SSg-Aiit8zZX1aQ2wA2GRvnP" class="button"><i class="fa fa-download"></i>Download Resume</a>
                     <a href="https://drive.google.com/uc?id=1NZRqqC1qmpWLxe2IYT0yTF5_GnrCgX3A" class="button"><i class="fa fa-download"></i>Download CV</a>
                  </p>
               </div>
            </div> <!-- end row -->
         </div> <!-- end .main-col -->
      </div>
   </section> <!-- About Section End-->


   <!-- Portfolio Section
   ================================================== -->
   <section id="portfolio">

      <div class="row">
         <div class="twelve columns collapsed">
            <h1>Professional works and side projects</h1>
            <!-- portfolio-wrapper -->
            <div id="portfolio-wrapper" class="bgrid-quarters s-bgrid-thirds cf">


               <!-- ----------------------------------------------------------------------------------------------------------------- -->
          	   <div class="columns portfolio-item">
                  <div class="item-wrap">
                     <a href="#modal-svd" title="">
                        <img alt="" src="https://drive.google.com/uc?id=10nIdCdWii74NjW7o1lp7UaC3OFbdDDhQ">
                          <div class="overlay">
       			              </div>
                           <div class="portfolio-item-meta">
          					      <h6>SVD of Monte Carlo variance reduction parameters</h6>
                              <h7>Analysis</h7>
          					   </div>
                        <div class="link-icon"><i class="icon-plus"></i></div>
                     </a>
                  </div>
          		</div> <!-- item end -->
                <!-- ----------------------------------------------------------------------------------------------------------------- -->

           <!-- ----------------------------------------------------------------------------------------------------------------- -->
       	   <div class="columns portfolio-item">
               <div class="item-wrap">
                  <a href="#modal-gtcadis" title="">
                     <img alt="" src="https://drive.google.com/uc?id=1es2HuTMVLPSSKd2kBxNnUSoqcG-nn1Ht">
                      <div class="overlay">
       			      </div>
                        <div class="portfolio-item-meta">
       					      <h6>Optimizing gamma dose rate calculations for nuclear fusion shielding</h6>
                           <h7>Analysis, dissertation</h7>
       					</div>
                     <div class="link-icon"><i class="icon-plus"></i></div>
                  </a>
               </div>
       		</div> <!-- item end -->
            <!-- ----------------------------------------------------------------------------------------------------------------- -->

                <!-- ----------------------------------------------------------------------------------------------------------------- -->
          	   <div class="columns portfolio-item">
                  <div class="item-wrap">
                     <a href="#modal-turbine" title="">
                        <img alt="" src="https://drive.google.com/uc?id=1oWlX4_7nT3ygydk0Ouv18m_VqfieQXav">
                          <div class="overlay">
       			              </div>
                           <div class="portfolio-item-meta">
          					      <h6>Tetrahedral mesh probability density functions</h6>
                              <h7>C++, Python</h7>
          					   </div>
                        <div class="link-icon"><i class="icon-plus"></i></div>
                     </a>
                  </div>
          		</div> <!-- item end -->
            <!-- ----------------------------------------------------------------------------------------------------------------- -->

           <!-- ----------------------------------------------------------------------------------------------------------------- -->
       	   <div class="columns portfolio-item">
               <div class="item-wrap">
                  <a href="#modal-cuda" title="">
                     <img alt="" src="https://drive.google.com/uc?id=1sgl8ZTIo38H89nSrwD6_MAaV8V6I7JJ-">
                          <div class="overlay">
       			              </div>
                        <div class="portfolio-item-meta">
       					      <h6>GPU-parallelized matrix LU decomposition with CUDA</h6>
                           <h7>C++, CUDA, coursework</h7>
       			    </div>
                     <div class="link-icon"><i class="icon-plus"></i></div>
                  </a>
               </div>
       		</div> <!-- item end -->
            <!-- ----------------------------------------------------------------------------------------------------------------- -->

           <!-- ----------------------------------------------------------------------------------------------------------------- -->
       	   <div class="columns portfolio-item">
               <div class="item-wrap">
                  <a href="#modal-fam" title="">
                     <img alt="" src="https://drive.google.com/uc?id=1OS9ovne50cJaL61I_yBEXClbiUzXMkMz">
                          <div class="overlay">
       			              </div>
                        <div class="portfolio-item-meta">
       					      <h6>Herald: a Python tool for automatically generating family trees</h6>
                           <h7>Python, side project</h7>
       					   </div>
                     <div class="link-icon"><i class="icon-plus"></i></div>
                  </a>
               </div>
       		</div> <!-- item end -->
            <!-- ----------------------------------------------------------------------------------------------------------------- -->

         <!-- COFFEE CUP EXAMPLE 
          	   <div class="columns portfolio-item">
                  <div class="item-wrap">
                     <a href="#modal-03" title="">
                        <img alt="" src="images/portfolio/coffee.jpg">
                        <div class="overlay">
                           <div class="portfolio-item-meta">
          					      <h5>Coffee</h5>
                              <p>Illustrration</p>
          					   </div>
                        </div>
                        <div class="link-icon"><i class="icon-plus"></i></div>
                     </a>
                  </div>
          		</div> 
            </div> 
         </div> 
        -->


         <!-- Modal Popup 
         ===================================================== -->

         <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-svd" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h3>Singular Value Decomposition (SVD) of Monte Carlo variance reduction parameters*</h3>

<h4>SVD basics</h4>

<p>
Singular Value Decomposition (SVD) is a matrix factorization method that has
applications in data compression and categorization problems.  For an $m \times
n$ matrix $\mathbf{A}$ the SVD is

$$\mathbf{A}_{m \times n}  = \mathbf{U}_{m \times m} \mathbf{\Sigma}_{m \times n} \mathbf{V}_{n \times n}^T,$$

where $\Sigma$ is a diagonal matrix. In this diagonal matrix, the entries
decrease monotonically. As a result, an estimate of $A$ can be formed by
truncating the $\mathbf{U}$, $\mathbf{\Sigma}$, and $\mathbf{V}$ matrices.
Specifically, an estimate of the $a_{ij}$ entry in the $\mathbf{A}$ matrix is

$$a_{ij} \approx \sum_{k=1}^K u_{ik} \sigma_{kk} v_{jk}.$$

In other words, an estimate of the $\mathbf{A}$ matrix &mdash; referred to as a
"reconstruction" &mdash; can be obtained by storing only the first $K$ rows in
$\mathbf{U}$, the first $K$ entries along the diagonal of $\mathbf{\Sigma}$,
and the first $K$ columns in $\mathbf{V}$, which may result in significant
memory savings. For example, consider the following $211 \times 340$ pixel
image of an eye.

<img  src="https://drive.google.com/uc?id=1ieRM8Ma512o94UAHrLNPh4gdpSEVSO7J" alt="" height="40%" width="40%" class="center" style="padding:20px;"/>

This image can be represented by a $211 \times 340$ matrix with entries
representing the color of each pixel (gray-scale values between 0 and 1).
Three reconstructions of this image are shown below.

<img  src="https://drive.google.com/uc?id=1X01YJz4YmtpMCXiqGWruuLSJcpIv1khH" alt="" height="70%" width="70%" class="center" style="padding:20px;" />

The $K=20$ reconstruction provides a fairly accurate representation of the image and requires an order of magnitude less storage.
</p>



<h4>Nuclear engineering application</h4>
<p>

Monte Carlo radiation transport calculations are used to assess the safety and
performance of nuclear reactors and other nuclear systems. These calculations
generally employ a class of techniques known as Monte Carlo variance reduction
in order to obtain results in reasonable CPU times. Variance reduction
techniques require "importance maps" to be stored in memory. These maps
estimate how important different regions of space (i.e. elements of a 3D mesh)
and energy are to the final solution. This requires a significant amount of
RAM, which can limit the fidelity of the simulation that can be achieved.

<br>

SVD can be used to compress the importance maps for reduced memory
requirements. In the example above, the $\mathbf{A}$ matrix represents the two
spatial dimensions of the eye image. Importance maps generally have 4
dimensions: $x$-, $y$-, and $z$-position, and energy. In this work, the 3
spatial dimensions are collapsed such that the the 2 dimensions of the
$\mathbf{A}$ matrix represent space and energy. A Python program was created in
order to decomposed these matrices using the <a
href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.svd.html">SciPy
implementation of SVD</a>.

While this work is still in progress, some preliminary analysis was done using a 
<a href="https://holtecinternational.com/productsandservices/wasteandfuelmanagement/dry-cask-and-storage-transport/hi-storm/">Holtec HI-STORM MPC</a> spent nuclear fuel storage cask with a simple photon source and photon detector, shown below. Note that this is a 2-D slice through a cylindrical fuel cask.

<img  src="https://drive.google.com/uc?id=1fq4j5g7WT_zvUocp9uwpLl8Lp706aZ9h" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

This problem used 1,922,000 spatial divisions (124$\times$124$\times$125) and
19 energy divisions. With this problem, an importance map was generated,
decomposed, and then reconstructed with all values of $K$ between 1 and 19 (the
full matrix). These reconstructed importance maps are shown below. Note these
are 2-D slices through the cylindrical fuel cask through the $z$-axis. Two
different energies are shown: $10-20$ Mega-electronvolts (MeV) and $100-200$
kilo-electronvolts (keV).

<img  src="https://drive.google.com/uc?id=1EyTdOpkP007hApwgw4EnebnmYUApNEVT" alt="" height="70%" width="70%" class="center" style="padding:20px;"/>

These plots qualitatively show that even $K = 1$ reconstructions match the
original importance map fairly well. The match is better at higher energies,
because at low energies the spatial shape of the importance map has a steeper
curvature.  In order to quantify how compressing these importance maps affects
performance, the standard Monte Carlo figure of merit was used, as given by

$$ {\text{figure of merit}} = \frac{1}{R^2t_{\text{proc}}}. $$

Here, $t_{\text{proc}}$ is the CPU time and $R$ is the relative error of the
final answer (i.e. the photon flux in the detector). For each
set of reconstructed importance maps, variance reduction parameters were
generated and photon transport simulations were run. The figure of merit plotted
as a function of $K$ is shown below.

<img  src="https://drive.google.com/uc?id=1eR0vF5sZReEOmzj76sflGE48xlWS8qRl" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

The line of best fit of this plot has a slope of 0.071, which indicates that
the performance of the Monte Carlo simulation is not a strong function of the
$K$ value used to reconstruct the importance map. The line of best fit
indicates that by using a $K=1$ reconstruction, the performance is only reduced
by a factor of 1.6, while reducing the memory requirements by a factor of 19.
This is a promising preliminary result and I will be publishing on more
detailed results shortly.

<br><br><i>*This work was cleared for public release as part of the 2017 Oak Ridge Postdoctoral Association Symposium</i>



                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-svd End -->
          <!-- ----------------------------------------------------------------------------------------------------------------- -->

         <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-gtcadis" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h3>Optimizing gamma dose rate calculations for nuclear fusion shielding</h3>
			      <p>
                    <a href="https://drive.google.com/uc?id=1P1zolvdd0gvulS6iJ3rjXvLGiOjNbl1M">Dissertation</a> <br>
                    <a href="https://doi.org/10.1080/00295639.2016.1275848"> 2017 journal article</a>    <br><br>

</p><h4>Theory</h4><p>

One of the challenges of designing and operating nuclear fusion reactors (such
as <a href="https://www.iter.org/mach">ITER</a>) is the creation of radioactive
materials. For most viable nuclear fusion fuels, the process of fusing atomic
nuclei releases high-energy neutrons.  These neutrons can penetrate through the
structural materials of the reactor and convert normally harmless materials
such as the iron in stainless steel or the hydrogen in water into radioactive
isotopes.  Even after the reactor is switched off, these isotopes will persist
and emit high-energy photons (gamma rays) as they decay.
Some of these photons travel to areas where people may be taking measurements
or doing maintenance, so it is necessary to estimate the potential biological
dose rate. This is generally done using Monte Carlo radiation transport, which
involves simulating the paths that particles take as they move through the
reactor and interact with the materials. 

<br><br>

From the standpoint of computer processing power, these calculations are not
possible without employing a class of techniques known as Monte Carlo variance
reduction.  Variance reduction techniques are used to optimize Monte Carlo
transport by first finding an approximate solution to an adjoint formulation of
the problem (though not all techniques are explicitly formulated this way).  This is done with respect to a detector response function. In
terms of a standard optimization problem, the variance of the detector response
function can be thought of as an objective function that should be minimized.  For decay photons,
defining this detector response function is straightforward, as I demonstrated
in earlier work <a href="https://doi.org/10.1016/j.fusengdes.2016.03.004">[2016
journal article]</a>.  For the neutrons that produce the decay photons, this
process is much more complicated.

<br><br>

As a component of my dissertation work I developed and implemented a technique
for automatically generating the neutron detector response function in order to
optimize Monte Carlo radiation transport for the aforementioned neutron problem.
The most difficult part of forming this function was approximating the process of "neutron activation"
in which material exposed to neutrons creates a vast network of radioactive 
products. For example when $^{62}\mathrm{Ni}$ is exposed to a neutrons, the following reactions, and many more, occur:

$$
{^{62}\mathrm{Ni}}
\xrightarrow{\textrm{(n, $\alpha$)}}
{^{59}\mathrm{Fe}}
\xrightarrow{\beta^-}
{^{59}\mathrm{Co}}
\begin{array}{ll}
\xrightarrow{\textrm{(n, $\gamma$)}}
{^{60}\mathrm{Co}} \\
\xrightarrow{\textrm{(n, $\gamma$)}}
{^{60\mathrm{m}}\mathrm{Co}}
\xrightarrow{\mathrm{IT}}
{^{60}\mathrm{Co}}
\end{array}
$$

In general, composition of materials before and after nuclear irradiation can be
related via the matrix exponential equation:

$$ \vec{N}(t) = e^{\mathbf{A}t} \vec{N}_0,$$

where $\vec{N}_0$ and $\vec{N}(t)$ are vectors describing the composition of a
material before and after neutron irradiation for time $t$. The $\mathbf{A}$ is
a matrix of reaction rates that depend on the rate in which neutrons pass
through a given area (the neutron flux). I developed a set of approximations
that can be used to simplify this matrix exponential such that it becomes a
linear operator with respect to neutron flux.  The details of this process can
be found in my dissertation/journal article linked at the top of this page, but
just for fun I will show the final answer for the optimal neutron detector
response function ($q^+_n$) that results from the approximation of
$\mathbf{A}$:

$$
\begin{align}
q^+_n(E_n, E_p) = \int_{E_p} \text{d}{E_p} \phi^+_p(E_p)
\sum\limits_{c} \lambda_{c, i_c} b_{c, i_c}(E_p)  N_{c,1}(0)  \Bigg\lbrack \Big\lbrack &\sigma_{c, 1 \rightarrow 2}(E_n) \frac{t_{\text{irr}}^{i_c-1}}{(i_c-1)!} \prod\limits_{j=3}^{i_c}  P_{c, j} \Big\rbrack e^{-d_{c, i_c} t_{\text{decay}}}\\
& + \sum_{j=2}^{i_c-1}  \Big\lbrack \sigma_{c, 1 \rightarrow 2}(E_n) \frac{t_{\text{irr}}^{j-1}}{(j-1)!} \prod\limits_{k=3}^{j}  P_{c, k}  \Big\rbrack B_{c,i_c,j}(t_{\text{decay}}) \Bigg\rbrack.
\end{align}
$$

<br>

</p><h4>Demonstration</h4><p>

Here I'll show that my method, which is called Groupwise Transmutation
Consistent Adjoint Driven Importance Sampling (GT-CADIS) improves the
convergence rate of Monte Carlo neutron transport by a factor of $O(10^2)$
relative to the industry-standard method known as Forward-Weighted (FW)-CADIS.
Consider a simple problem shown below consisting of a block of stainless steel
(gray) with a U-shaped air-duct, a neutron source (blue) and a region (orange)
where we'd like to estimate the biological dose rate from photons after neutron
irradiation.

<img  src="https://drive.google.com/uc?id=1JS_Y4xy8cFAP_cVv7iSmUyW80JjqDBZz" alt="" height="60%" width="60%" class="center" style="padding:20px;"/>

Using FW-CADIS, neutron detector response function is shown below.

<img  src="https://drive.google.com/uc?id=1WvGWzdBw6j_sp5R0bqXt0sOs4CJ95X32" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

Recall that the variance of this function can be thought of as the guess for
the objective function. With GT-CADIS, the neutron detector response function
has a much different shape: the intensity is much higher in the regions of
stainless steel that border the air duct. Note that only the shape is important here, not the magnitude (or even units!).

<img  src="https://drive.google.com/uc?id=1J1cUk6NsQtWM2H2etHdjfvKZnPviUP8u" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

I generated variance reduction parameters using both detector response
functions and tracked the rate of convergence of Monte Carlo simulations using
each set.  The image below shows the relative error in the neutron flux as a
function of neutron transport processor time using GT-CADIS and FW-CADIS
variance reduction parameters, as well as no variance reduction. Without
variance reduction, the neutron flux converges fastest near the source. With
FW-CADIS the neutron flux converges at a roughly uniform rate throughout the
problem. With GT-CADIS, the neutron flux converges fastest in the area
immediately surrounding the area of interest, as expected.

<img  src="https://drive.google.com/uc?id=1dLbb3tez6mF3dFB5Nq7EV-GK53K_5wl-" alt="" height="60%" width="60%" class="center" style="padding:20px;"/>

In order to quantify how much faster the simulation converges with GT-CADIS, the Monte Carlo figure of merit was used, as defined by 

$$ {\text{figure of merit}} = \frac{1}{R^2t_{\text{proc}}}, $$

where R is the relative error of the photon flux in the region of interest
(e.g. the orange sphere in the geometry image) and $t_{\text{proc}}$ is the
neutron transport processor time. The figure of merit converges to a constant
value during a simulation, as seen in the plot below.

<img  src="https://drive.google.com/uc?id=1zF4T2jgIt5XQW5OkB7s34QIWQ8H274La" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

The ratio of figure of merits is the speedup. GT-CADIS was found to provide
speedups of $200 \pm 100$ relative to FW-CADIS and $9 \pm 5 \times 10^5$
relative to simulations without variance reduction. In other words, GT-CADIS
drastically reduces the required computational resources necessary for
calculating these photon dose rates.

                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-gtcadis End -->
          <!-- ----------------------------------------------------------------------------------------------------------------- -->

         <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-turbine" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h4>Tetrahedral mesh probability density functions</h4>
			      <p>
                    <a href="https://github.com/pyne/pyne/blob/develop/src/source_sampling.cpp">C++ source</a> 
                    <br>
                    <a href="https://github.com/pyne/pyne/blob/develop/tests/test_source_sampling.py">Unit tests (via Python wrapper)</a>
                    <br>
                    <a href="http://pyne.io/theorymanual/source_sampling.html">Theory, sample calculations to match unit tests</a>
                    <br>
                    <a href="http://pyne.io/usersguide/source_sampling.html">User's guide</a>
                    <br><br>

Nuclear systems analysis often involves using the Monte Carlo approach to
simulate the paths that particles (i.e. neutrons and high-energy photons) take
after they are emitted from a source. This source may be a reactor core,
particle accelerator, or a radioactive seed used in radiation oncology. When
using the Monte Carlo approach, the source must be represented as a probability
density function (PDF) that typically varies as a function of position and
energy (i.e. energy of the emitted particle).  With-industry standard Monte
Carlo radiation transport codes such as <a
href="https://mcnp.lanl.gov/mcnp5.shtml">MCNP5</a>, users must specify these
PDFs through the combination of rudimentary 1-dimensional PDFs such has
histogram, linear, and point-wise distributions.  There are many cases when the
PDF is too complex for this method to be practical, such as cases where
particles are emitted from nuclear fusion plasmas or irradiated structural
materials.

<br><br>

I have added code to the <a href="https://github.com/pyne/pyne">Python for
Nuclear Engineering</a> toolkit for the creation of energy-dependent Cartesian-
or tetrahedral mesh-based PDFs. These PDF can be sampling using unbiased and
biased sampling techniques that allow for the use of Monte Carlo variance
reduction. Sampling is done using the <a
href="http://ieeexplore.ieee.org/document/4245054/?reload=true">Alias
method</a>, which allows for O(1) scaling with respect to the number of
discrete bins in the PDF. My code is written in C++ and also has Python and
Fortran interfaces and can be compiled directly into existing Monte Carlo codes.
More information can be found in the links at the top of this page.

<br><br>

Here's a quick demonstration of how this code can be used to create extremely
complex particle sources.  Consider this CAD model of a turbine rotor I found on
<a href="https://grabcad.com/">GrabCAD</a>. 

<img  src="https://drive.google.com/uc?id=1d0WAQUJQP_3BkGWZHfF6iThxfzYd6MyP" alt="" height="30%" width="30%" class="center" style="padding:20px;"/>

I created a conformal tetrahedral mesh of this model using <a
href="https://cubit.sandia.gov/">CUBIT</a>. I then iterated through tetrahedral
elements of the mesh and assigned a source strength to each element based on the
$x$, $y$, $z$ coordinates of the center of the element using this equation:


$$q(x, y, z) = sin\left(\frac{x^2 + y^2 + (z + 10)^2}{1200}\right) + 1.$$

This equation does not have any physical significance, but it serves as a good
example because it would not be possible to represent using industry-standard
Monte Carlo codes. The resulting particle source PDF is shown below.

<img  src="https://drive.google.com/uc?id=1OnJxs8PUgx5vi6pzDqbXruKd45Ds5k0-" alt="" height="38%" width="38%" class="center" style="padding:20px;"/>

I compiled my C++ routine directly into MCNP via the Fortran interface I
created. I was then able to use the PDF shown above as a particle source for a
photon transport simulation. Below is an image showing the photon flux
distribution.

<img  src="https://drive.google.com/uc?id=1JJ6Gzu6YhwyqWUaDwKPjd7bPti00G9DK" alt="" height="45%" width="45%" class="center" style="padding:20px;"/>

Although this example was just for fun, I have used this code as a component of
a software system I created for estimating biological dose rates for nuclear
fusion reactors problems <a href="https://doi.org/10.1016/j.fusengdes.2016.03.004">[2016
journal article]</a>. 


                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-turbine End -->
          <!-- ----------------------------------------------------------------------------------------------------------------- -->

         <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-cuda" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h4>GPU-parallelized matrix LU decomposition with CUDA</h4>
			      <p>
                    <a href="https://github.com/elliottbiondo/ME759_final_project">C++ source</a> 
                    <br>
                    <a href="https://drive.google.com/uc?id=109i9abkckd_H7_TjX6rYnNYml797JjjT">Report</a> 
                    <br><br>

In grad school, one of my favorite courses was <a
href="http://sbel.wisc.edu/Courses/ME964/">ME759: High-Performance Computing
for Applications in Engineering</a>. The primary focus of this course was GPU
computing with CUDA, though we spent some time with MPI and OpenMP as well.
For my final project, I wrote a program to solve a system of linear equations
on the GPU. The problem I solved takes the form 

$$ A_{n \times n} x_{n \times m} = b_{n \times m} $$

where $A$ is a diagonally-dominant banded matrix with some bandwidth $k$.
Problems of this form may arise when using numerical methods to solve ordinary
and partial differential equations. This equation can be solved in 3 steps: LU
decomposition, forward substitution, and backward substitution.  For brevity,
I'll only discuss the first step here. More details can be found in the links at
the top of this page.  LU decomposition decomposes the $A$ matrix into lower-
and upper-triangular matrices $L$ and $U$:

$$ A = LU. $$

The algorithm I chose for performing this decomposition is shown below.

</p>
<div>
<pre><code>
<number>1</number>    <em>for</em> i = 0 to n−2
<number>2</number>    
<number>3</number>        <em>for</em> j = i+1 to n−1
<number>4</number>            A[j, i] = A[j, i]/A[i,i]
<number>5</number>        <em>end for</em>
<number>6</number>    
<number>7</number>        <em>for</em> j = i+1 to n−1
<number>8</number>            <em>for</em> k = i+1 to n−1
<number>9</number>                A[j, k] = A[j , k] − A[j, i]∗A[i, k]
<number>10</number>           <em>end for</em>
<number>11</number>       <em>end for</em>
<number>12</number>   
<number>13</number>   <em>end for</em>
</code></pre>
</div>
<p>

This algorithm operates on the matrix in-place, such that resultant $L$ and $U$
matrices are produced within the lower and upper triangular portion of the
original $A$ matrix, which helps to minimize memory usage.

<br><br>

I adapted this algorithm to run efficiently on the GPU using CUDA.  This
algorithm requires synchronization after the for-loop on line 3 and the set of
for-loops beginning on line 7. Though CUDA can impose synchronization between
threads within a block, there is no notion of block synchronization. As a
result, the outermost for-loop must occur on the CPU, and this for-loop must
call 2 separate CUDA kernels: one for the line 3 for-loop and one for the line
7 for-loops. The line 7 for-loops offered the best potential for
parallelization.  No synchronization is required over $j$ or $k$, so large
portions of the $A$ matrix can be operated on by different threads
simultaneously. This is illustrated in the following diagram. The rectangles
represent the active region of the matrix for a given kernel call where the
order of kernel calls goes from light to dark.  Within each rectangle,
execution is divided into blocks, and threads within these blocks perform the
operation appearing on line 9 simultaneously.

<img  src="https://drive.google.com/uc?id=1SiEYCfoq785w2-iht2jKSrmB_nLVXTtg" alt="" height="30%" width="30%" class="center" style="padding:20px;"/>

Further memory usage reductions were achieved by using the <a
href="http://www.netlib.org/lapack/lug/node124.html">band storage</a>
technique. This technique only stores the values within the band of the matrix. As a result, the active region of the matrix in my implementation proceeds according to the following diagram.

<img  src="https://drive.google.com/uc?id=1BOv_JyQ-f-G3BwTMglf0VvTBdlpIvUcs" alt="" height="23%" width="23%" class="center" style="padding:20px;"/>

The aforementioned forward and backward substitution steps were also
implemented. The performance of the program was compared to the <a
href="https://software.intel.com/en-us/mkl">Intel Math Kernel Library (MKL)</a>
on the CPU.  The following plot shows the execution time necessarily to solve a
linear system with an $A$ matrix of size $n$, with bandwidths $k$ that are 10%,
50% and 90% of $n$. The results of this plot are for the case where $m=1$, but
scaling analysis was done over $m$ as well.

<img  src="https://drive.google.com/uc?id=13yieiN7U70dPzAtvjhJXnb8vOHOspge4" alt="" height="50%" width="50%" class="center" style="padding:20px;"/>

This plot shows that my CUDA implementation is marginally faster than MKL over a range of matrix dimensions and bandwidths.

                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-cuda End -->
         <!-- ----------------------------------------------------------------------------------------------------------------- -->

         <!-- ----------------------------------------------------------------------------------------------------------------- -->
         <div id="modal-fam" class="popup-modal mfp-hide">
		      <div class="description-box">
			      <h4>Herald: a Python tool for automatically generating family trees</h4>
			      <p>
                    <a href="https://github.com/elliottbiondo/herald">Python source</a> 
                    <br><br>

I have been researching my genealogy as a hobby for the past 5 years or so.
I've accrued information on hundreds of direct ancestors going back as far as
William the Conqueror (c. 1028 - 1087). There are tons of genealogy tools out
there, but none of them were entirely satisfactory to me. In the throes of
writing my dissertation I needed a fun coding project, so I threw this together
in a few Sunday mornings. This project, which I call Herald, is written in
Python. Herald reads text-based input files and creates
PDF output files via SVG.  This is an ongoing project, so right now only direct
decent is supported (i.e.  parent, grand-parent, ...,
[$N\times$great]-grand-parent).

I came up with a very simple recursive algorithm for generating the tree (which
is appropriately a tree in the graph-theory sense). 

</p>
<pre><code>
<number>1</number>     <em>function</em> <var>assign_index</var>(Person person, string index)
<number>2</number>         person.set_index(index)
<number>3</number>     
<number>4</number>             <em>if</em> person.mother():
<number>5</number>                 <var>assign_index</var>(person.mother(), person.index() +'1')
<number>6</number>             <em>end if</em>
<number>7</number>     
<number>8</number>             <em>if</em> person.father():
<number>9</number>                 <var>assign</var>(person.father, person.index() + '0')
<number>10</number>            <em>end if</em>
<number>11</number>    
<number>12</number>    <em>end function</em>
</code></pre>
<p>

This function is called from the root of the tree (e.g. the person whose
ancestor's you'd like to plot). Each person in the tree is assigned an index
string. The length of the string is the generation they belongs to. For
example, <code>'010'</code> denotes the father's mother's father
(great-grandfather) of the root person. The generation that this person belong
to is <code><em>len</em>('101') = 3</code>. In typical family trees, the
left-most branch is the paternal line (i.e. '1111...1') and the right-most
branch is the maternal line (i.e. '0000...1'). When printing a family tree,
members of a given generation can be sorted from left to right by simply
converting index values to binary (e.g. <code>'1101' = 13</code>) and sorting
using the decimal representation. A portion of my family tree is shown below.  

<img  src="https://drive.google.com/uc?id=1OS9ovne50cJaL61I_yBEXClbiUzXMkMz" alt="" height="70%" width="70%" class="center" style="padding:20px;"/>

                  <p/>
		      </div>
            <div class="link-box">
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div><!-- modal-fam End -->
         <!-- ----------------------------------------------------------------------------------------------------------------- -->

         <!-- COFFEE CUP EXAMPLE
         <div id="modal-03" class="popup-modal mfp-hide">
		      <img class="scale-with-grid" src="images/portfolio/modals/m-coffee.jpg" alt="" />
		      <div class="description-box">
			      <h4>Coffee Cup</h4>
			      <p>Proin gravida nibh vel velit auctor aliquet. 
			      <p>Proin gravida nibh vel velit auctor aliquet. 
			      <p>Proin gravida nibh vel velit auctor aliquet. 
               <span class="categories"><i class="fa fa-tag"></i>Branding, Webdesign</span>
		      </div>
            <div class="link-box">
               <a href="http://www.behance.net">Details</a>
		         <a class="popup-modal-dismiss">Close</a>
            </div>
	      </div>
        -->


      </div> <!-- row End -->
   </section> <!-- Portfolio Section End-->


   <section id="publications">
      <div class="row ">
        <div class="twelve columns">
            <h1>Selected Publications</h1>
            <ol>
            <li> <span>E. Biondo</span>, P. Wilson, “Transmutation Approximations for the
            Application of Hybrid Monte Carlo/Deterministic Neutron Transport to Shutdown
            Dose Rate Analysis,” <em>Nuclear Science and Engineering</em>, Vol.  187, Issue
            1, pp. 27-48, 2017. <a href="https://doi.org/10.1080/00295639.2016.1275848">[link]</a>
            <li> <span>E. Biondo</span>, A. Davis, P. Wilson, “Shutdown Dose Rate Analysis with
            CAD Geometry, Cartesian/Tetrahedral Mesh, and Advanced Variance Reduction,”
            <em>Fusion Engineering and Design</em>, Vol. 106, pp. 77–84, 2016. <a href="https://doi.org/10.1016/j.fusengdes.2016.03.004">[link]</a>
            <li> <span>E. Biondo</span>, G. Davidson, T. Pandya, S. Hamilton, T. Evans,
            “Deterministically Estimated Fission Source Distributions for Monte Carlo
            k-Eigenvalue Problems,” <em>Annals of Nuclear Energy</em>, Submitted February
            2018.
            <li> <span>E. Biondo</span>, P. Wilson, “Application of the Multi-Step CADIS Method
            to Fusion Energy Systems Analysis,” <em>International Conference on Mathematics
            & Computational Methods Applied to Nuclear Science & Engineering</em>, Jeju,
            South Korea, 2017.
            <li> <span>E. Biondo</span>, A. Ibrahim, S. Mosher, R. Grove. “Accelerating Fusion
            Reactor Neutronics Modeling by Automatic Coupling of Hybrid Monte
            Carlo/Deterministic Transport on CAD Geometry.” <em>Joint International
            Conference on Mathematics and Computation (M&C), Supercomputing in Nuclear
            Applications (SNA) and the Monte Carlo (MC) Method (ANS MC2015)</em>, Nashville,
            TN, 2015. 
            </ol>
        </div>
   </div>
   </section> <!-- Publication Section End-->

<!-- ==========================================================================
   <!-- Resume Section
   ================================================== - ->
   <section id="resume">

      <!-- Education
       ================================================== - ->
      <div class="row education">
         <div class="three columns header-col">
            <h1><span>Education</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <h3>University of Wisconsin</h3>
                  <p class="info">Ph.D. in Nuclear Engineering and Engineering Physics <span>&bull;</span> <em class="date">August 2016</em></p>
                  <p>
                        
                    <a href="https://drive.google.com/uc?id=1P1zolvdd0gvulS6iJ3rjXvLGiOjNbl1M">Python source</a> 
                  </p>
               </div>
            </div> <!-- item end - ->

            <div class="row item">
               <div class="twelve columns">
                  <h3>University of Minnesota</h3>
                  <p class="info">B.ChE in Chemical Engineering, B.S. in Chemistry<span>&bull;</span> <em class="date">May 2011</em></p>
                  <p>


                    Co-President of the UMN American Institute of Chemical Engineers, leader of the UMN 
                    <a href="https://www.youtube.com/watch?v=turn8qJi4Uw">Chem-E-Car Team</a>, and
                    student member of the College of Engineering Curriculum Council.

                  </p>
               </div>
            </div> <!-- item end - ->
         </div> <!-- main-col end - ->
      </div> <!-- End Education - ->


      <!-- Work 
      ========================================================= - ->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>Work</span></h1>
         </div>
    
             <div class="nine columns main-col">
                <div class="row item">
                   <div class="twelve columns">
                      <h3>Oak Ridge National Laboratory</h3>
                      <p class="info">Postdoctoral Researcher <span>&bull;</span> <em class="date">November 2016 - Present</em></p>
                      <p>
                    afdasdfasdfasdf
                  </p>
               </div>
            </div> <!-- item end - ->

         </div> <!-- main-col end - ->
      </div> <!-- End Work - ->

   <!-- Skills  Section
   ================================================== - ->
      <div class="row skill">

         <div class="three columns header-col">
            <h1><span>Skills</span></h1>
         </div>

         <div class="nine columns main-col">

            <p>Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam,
            </p>

				<div class="bars">
				   <ul class="skills">
					    <li><span class="bar-expand python"></span><em>Python</em></li>
                        <li><span class="bar-expand cpp"></span><em>C++</em></li>
                        <li><span class="bar-expand cuda"></span><em>CUDA</em></li>
                        <li><span class="bar-expand matlab"></span><em>MATLAB</em></li>
                        <li><span class="bar-expand git"></span><em>git</em></li>
                        <li><span class="bar-expand latex"></span><em>LaTeX</em></li>
					</ul>
				</div> <!-- end skill-bars - ->

			</div> <!-- main-col end - ->

      </div> <!-- End skills - ->

   </section> <!-- Resume Section End- ->
========================================================================== -->



   <!-- footer
   ================================================== -->
   <footer>
      <div class="row">
         <div id="go-top"><a class="smoothscroll" title="Back to Top" href="#home"><i class="icon-up-open"></i></a></div>
      </div>
   </footer> <!-- Footer End-->

   <!-- Java Script
   ================================================== -->
   <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
   <script>window.jQuery || document.write('<script src="js/jquery-1.10.2.min.js"><\/script>')</script>
   <script type="text/javascript" src="js/jquery-migrate-1.2.1.min.js"></script>

   <script src="js/jquery.flexslider.js"></script>
   <script src="js/waypoints.js"></script>
   <script src="js/jquery.fittext.js"></script>
   <script src="js/magnific-popup.js"></script>
   <script src="js/init.js"></script>

</body>

</html>
